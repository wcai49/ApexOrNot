# 题目:
##### 给定一个二叉搜索树,按中序遍历将其重新排列为一棵递增顺序搜索树,使树的最左边节点成为根节点,并且每个节点没有左子节点,只有一个右子节点.

### Terms
二叉树有广度遍历和深度遍历两类方式, 广度遍历就是最好理解的层次遍历, 从上到下, 从左到右的顺序遍历整个树; 深度遍历就有前序, 中序, 后续 (pre order, in order, post order)三种.
用简单的三个图来展示这三种深度遍历的规则:

![preorder.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25_26/preOder.png)

![inorder.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25_26/inOrder.png)

![postorder.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25/_26postOrder.png)
### 图示
图例1：

![递增顺序搜索树示例1.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25_26/figure1.png)

**对于二叉搜索树，该图例的输入root即为:[5, 3, 6, 2, 4, null, 8, 1, null, null, null, 7, 9];**

**要求获得的新树， 输出则为: [1, null, 2, null, 3, null, 4, null, 5, null, 6, null, 7, null, 8, null, 9]。**

图例2：

![递增顺序搜索树示例2.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25_26/figure2.png)

**该图例的root输入为: [5, 1, 7]；**
**需求输出为:[1, null, 5, null, 7]。**



### 题解1
*~~因为对于二叉树的掌握不是非常好，所以在刚开始接触题目的时候选择了直接看官方答案。现在整理的时候，直接复现一遍。~~*

#### 解题思路： 
1.先将整个树遍历一遍，按照顺序放入Array中；2.生成一棵新的树，根据Array长度、逐个创建新的节点，连接成新的树。
#### 代码片

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var increasingBST = function(root) {
    let orderArray = [];
    
    //第一步，遍历二叉树，中序排列
    reOrderTN(root, orderArray);
    //第二部，生成新树
    let resultTree = new TreeNode(0);
    let toolTree = resultTree;
    
    for(let i = 0; i < orderArray.length; i++){
        toolTree.right = new TreeNode(orderArray[i]);
        toolTree = toolTree.right;
    }
    //注意，这里(工具人)toolTree = resultTree, 用于给每个树节点赋值，再进行到下一个节点。结束之后，resultTree会保留toolTree生成的指针链路关系，
    //由于我们生成的是new TreeNode(0), 因此我们此时的resultTree的第一个节点还是0，所以return的时候要切掉。
    return resultTree.right;
}

//二叉树中序排列, 经过此递归之后，root会被排列成按照顺序的数组，例如示例1就会被排列成为[1,2,3,4,5,6,7,8,9]
const reOrderTN = function(treenodes, array) {
    if(treenodes === null) {
        return;
    }
    reOrderTN(treenodes.left, array);
    array.push(treenodes.val);
    reOrderTN(treenodes.right, array);
}
```

#### 提交结果
![递增顺序搜索树——题解1结果.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25_26/result1.PNG)

此方法首先中序遍历了整个树，接着遍历Array去生成新的树；

### 题解2
#### 解题思路： 
同样是需要中序遍历，能不能在递归的过程中顺便把树的结构调整好呢？
#### 代码片

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var increasingBST = function(root) {
    let resultTree = new TreeNode(-1);
    let toolTree = resultTree;
    
    const inOrder = (node) => {
        if(node === null) {
            return;
        }
        
        inOrder(node.left);
        
        toolTree.right = node;
        node.left = null;
        toolTree = node;
        
        inOrder(node.right);    
    }
    
    inOrder(root);
    return resultTree.right;
}
```
#### 提交结果
![result2.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25_26/result2.PNG)
