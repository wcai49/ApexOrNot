# 题目:
##### 给定一个二叉搜索树,按中序遍历将其重新排列为一棵递增顺序搜索树,使树的最左边节点成为根节点,并且每个节点没有左子节点,只有一个右子节点.


### 图示
图例1：
![递增顺序搜索树示例1.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25/%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E4%BE%8B1.png)

**对于二叉搜索树，该图例的输入root即为:[5, 3, 6, 2, 4, null, 8, 1, null, null, null, 7, 9];**

**要求获得的新树， 输出则为: [1, null, 2, null, 3, null, 4, null, 5, null, 6, null, 7, null, 8, null, 9]。**

图例2：

![递增顺序搜索树示例2.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25/%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E4%BE%8B2.png)

**该图例的root输入为: [5, 1, 7]；**
**需求输出为:[1, null, 5, null, 7]。**

中序排列
图解中序排列

### 题解1
*~~因为对于二叉树的掌握不是非常好，所以在刚开始接触题目的时候选择了直接看官方答案。现在整理的时候，直接复现一遍。~~*

#### 解题思路： 
1.先将整个树遍历一遍，按照顺序放入Array中；2.生成一棵新的树，根据Array长度、逐个创建新的节点，连接成新的树。
#### 代码片

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var increasingBST = function(root) {
    let orderArray = [];
    
    //第一步，遍历二叉树，中序排列
    reOrderTN(root, orderArray);
    //第二部，生成新树
    let resultTree = new TreeNode(0);
    let toolTree = resultTree;
    
    for(let i = 0; i < orderArray.length; i++){
        toolTree.right = new TreeNode(orderArray[i]);
        toolTree = toolTree.right;
    }
    //注意，这里(工具人)toolTree = resultTree, 用于给每个树节点赋值，再进行到下一个节点。结束之后，resultTree会保留toolTree生成的指针链路关系，
    //由于我们生成的是new TreeNode(0), 因此我们此时的resultTree的第一个节点还是0，所以return的时候要切掉。
    return resultTree.right;
}

//二叉树中序排列, 经过此递归之后，root会被排列成按照顺序的数组，例如示例1就会被排列成为[1,2,3,4,5,6,7,8,9]
const reOrderTN = function(treenodes, array) {
    if(treenodes === null) {
        return;
    }
    reOrderTN(treenodes.left, array);
    array.push(treenodes.val);
    reOrderTN(treenodes.right, array);
}
```

#### 提交结果
![递增顺序搜索树——题解1结果.png](https://github.com/wcai49/ApexOrNot/blob/oldCai/2021-04-25/result1.PNG)

可以看到， 由于遍历了一遍二叉树，又递归了整个树去排序，导致用时较长；同时，因为生成了新的Array，又用到了工具人toolTree，导致内存占用也比较高。怎样才能优化呢？

### 题解2
#### 图示
#### 代码片
#### 提交结果
